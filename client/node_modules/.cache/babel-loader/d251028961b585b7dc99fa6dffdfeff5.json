{"ast":null,"code":"'use strict';\n\nconst generate = require('regjsgen').generate;\n\nconst parse = require('regjsparser').parse;\n\nconst regenerate = require('regenerate');\n\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\n\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nconst iuMappings = require('./data/iu-mappings.js');\n\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js'); // Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\n\n\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\n\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\n\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A, // Line Feed <LF>\n0x000D, // Carriage Return <CR>\n0x2028, // Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n\n  return ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = dotAll => {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;\n\n  try {\n    return require(`regenerate-unicode-properties/${path}.js`);\n  } catch (exception) {\n    throw new Error(`Failed to recognize value \\`${value}\\` for property ` + `\\`${property}\\`.`);\n  }\n};\n\nconst handleLoneUnicodePropertyNameOrValue = value => {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    const property = 'General_Category';\n    const category = unicodeMatchPropertyValue(property, value);\n    return getUnicodePropertyValueSet(property, category);\n  } catch (exception) {} // It’s not a `General_Category` value, so check if it’s a binary\n  // property. Note: `unicodeMatchProperty` throws on invalid properties.\n\n\n  const property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n  const parts = value.split('=');\n  const firstPart = parts[0];\n  let set;\n\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    const property = unicodeMatchProperty(firstPart);\n    const value = unicodeMatchPropertyValue(property, parts[1]);\n    set = getUnicodePropertyValueSet(property, value);\n  }\n\n  if (isNegative) {\n    return UNICODE_SET.clone().remove(set);\n  }\n\n  return set.clone();\n}; // Given a range of code points, add any case-folded code points in that range\n// to a set.\n\n\nregenerate.prototype.iuAddRange = function (min, max) {\n  const $this = this;\n\n  do {\n    const folded = caseFold(min);\n\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nconst update = (item, pattern) => {\n  let tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n\n  Object.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': `(?:${pattern})`\n  };\n};\n\nconst caseFold = codePoint => {\n  return iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n  const set = regenerate();\n\n  for (const item of characterClassItem.body) {\n    switch (item.type) {\n      case 'value':\n        set.add(item.codePoint);\n\n        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n          const folded = caseFold(item.codePoint);\n\n          if (folded) {\n            set.add(folded);\n          }\n        }\n\n        break;\n\n      case 'characterClassRange':\n        const min = item.min.codePoint;\n        const max = item.max.codePoint;\n        set.addRange(min, max);\n\n        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n          set.iuAddRange(min, max);\n        }\n\n        break;\n\n      case 'characterClassEscape':\n        set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));\n        break;\n\n      case 'unicodePropertyEscape':\n        set.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n        break;\n      // The `default` clause is only here as a safeguard; it should never be\n      // reached. Code coverage tools should ignore it.\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(`Unknown term type: ${item.type}`);\n    }\n  }\n\n  if (characterClassItem.negative) {\n    update(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`);\n  } else {\n    update(characterClassItem, set.toString(regenerateOptions));\n  }\n\n  return characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n  delete item.name;\n  item.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = groups => {\n  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n  }\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n  switch (item.type) {\n    case 'dot':\n      if (config.useDotAllFlag) {\n        break;\n      } else if (config.unicode) {\n        update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));\n      } else if (config.dotAll) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n\n      break;\n\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n\n    case 'unicodePropertyEscape':\n      if (config.unicodePropertyEscape) {\n        update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));\n      }\n\n      break;\n\n    case 'characterClassEscape':\n      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));\n      break;\n\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n\n      if (item.name && config.namedGroup) {\n        const name = item.name.value;\n\n        if (groups.names[name]) {\n          throw new Error(`Multiple groups with the same name (${name}) are not allowed.`);\n        }\n\n        const index = groups.lastIndex;\n        delete item.name;\n        groups.names[name] = index;\n\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n\n        if (groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name].forEach(reference => {\n            updateNamedReference(reference, index);\n          });\n          delete groups.unmatchedReferences[name];\n        }\n      }\n\n    /* falls through */\n\n    case 'alternative':\n    case 'disjunction':\n    case 'quantifier':\n      item.body = item.body.map(term => {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'value':\n      const codePoint = item.codePoint;\n      const set = regenerate(codePoint);\n\n      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n        const folded = caseFold(codePoint);\n\n        if (folded) {\n          set.add(folded);\n        }\n      }\n\n      update(item, set.toString(regenerateOptions));\n      break;\n\n    case 'reference':\n      if (item.name) {\n        const name = item.name.value;\n        const index = groups.names[name];\n\n        if (index) {\n          updateNamedReference(item, index);\n          break;\n        }\n\n        if (!groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name] = [];\n        } // Keep track of references used before the corresponding group.\n\n\n        groups.unmatchedReferences[name].push(item);\n      }\n\n      break;\n\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(`Unknown term type: ${item.type}`);\n  }\n\n  return item;\n};\n\nconst config = {\n  'ignoreCase': false,\n  'unicode': false,\n  'dotAll': false,\n  'useDotAllFlag': false,\n  'useUnicodeFlag': false,\n  'unicodePropertyEscape': false,\n  'namedGroup': false\n};\n\nconst rewritePattern = (pattern, flags, options) => {\n  config.unicode = flags && flags.includes('u');\n  const regjsparserFeatures = {\n    'unicodePropertyEscape': config.unicode,\n    'namedGroups': true,\n    'lookbehind': options && options.lookbehind\n  };\n  config.ignoreCase = flags && flags.includes('i');\n  const supportDotAllFlag = options && options.dotAllFlag;\n  config.dotAll = supportDotAllFlag && flags && flags.includes('s');\n  config.namedGroup = options && options.namedGroup;\n  config.useDotAllFlag = options && options.useDotAllFlag;\n  config.useUnicodeFlag = options && options.useUnicodeFlag;\n  config.unicodePropertyEscape = options && options.unicodePropertyEscape;\n\n  if (supportDotAllFlag && config.useDotAllFlag) {\n    throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n  }\n\n  const regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.unicode\n  };\n  const groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: index }\n    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\n  };\n  const tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.\n\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\n\nmodule.exports = rewritePattern;","map":{"version":3,"sources":["C:/Users/DEV. mmm/Documents/projects/Premium Pension/Agent mapping/Account-mapping/client/node_modules/regexpu-core/rewrite-pattern.js"],"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","prototype","iuAddRange","min","max","$this","folded","caseFold","add","update","item","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","processCharacterClass","characterClassItem","regenerateOptions","body","negative","toString","updateNamedReference","index","name","matchIndex","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","useDotAllFlag","unicodePropertyEscape","behavior","lastIndex","namedGroup","names","onNamedGroup","call","forEach","reference","map","term","push","rewritePattern","flags","options","includes","regjsparserFeatures","lookbehind","supportDotAllFlag","dotAllFlag","create","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst generate = require('regjsgen').generate;\r\nconst parse = require('regjsparser').parse;\r\nconst regenerate = require('regenerate');\r\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\r\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\r\nconst iuMappings = require('./data/iu-mappings.js');\r\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\r\n\r\n// Prepare a Regenerate set containing all code points, used for negative\r\n// character classes (if any).\r\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\r\n// Without the `u` flag, the range stops at 0xFFFF.\r\n// https://mths.be/es6#sec-pattern-semantics\r\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\r\n\r\n// Prepare a Regenerate set containing all code points that are supposed to be\r\n// matched by `/./u`. https://mths.be/es6#sec-atom\r\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\r\n\t.remove(\r\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\r\n\t\t0x000A, // Line Feed <LF>\r\n\t\t0x000D, // Carriage Return <CR>\r\n\t\t0x2028, // Line Separator <LS>\r\n\t\t0x2029  // Paragraph Separator <PS>\r\n\t);\r\n\r\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\r\n\tif (unicode) {\r\n\t\tif (ignoreCase) {\r\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\r\n\t\t}\r\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\r\n\t}\r\n\treturn ESCAPE_SETS.REGULAR.get(character);\r\n};\r\n\r\nconst getUnicodeDotSet = (dotAll) => {\r\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\r\n};\r\n\r\nconst getUnicodePropertyValueSet = (property, value) => {\r\n\tconst path = value ?\r\n\t\t`${ property }/${ value }` :\r\n\t\t`Binary_Property/${ property }`;\r\n\ttry {\r\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\r\n\t} catch (exception) {\r\n\t\tthrow new Error(\r\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\r\n\t\t\t`\\`${ property }\\`.`\r\n\t\t);\r\n\t}\r\n};\r\n\r\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\r\n\t// It could be a `General_Category` value or a binary property.\r\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\r\n\ttry {\r\n\t\tconst property = 'General_Category';\r\n\t\tconst category = unicodeMatchPropertyValue(property, value);\r\n\t\treturn getUnicodePropertyValueSet(property, category);\r\n\t} catch (exception) {}\r\n\t// It’s not a `General_Category` value, so check if it’s a binary\r\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\r\n\tconst property = unicodeMatchProperty(value);\r\n\treturn getUnicodePropertyValueSet(property);\r\n};\r\n\r\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\r\n\tconst parts = value.split('=');\r\n\tconst firstPart = parts[0];\r\n\tlet set;\r\n\tif (parts.length == 1) {\r\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\r\n\t} else {\r\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\r\n\t\tconst property = unicodeMatchProperty(firstPart);\r\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\r\n\t\tset = getUnicodePropertyValueSet(property, value);\r\n\t}\r\n\tif (isNegative) {\r\n\t\treturn UNICODE_SET.clone().remove(set);\r\n\t}\r\n\treturn set.clone();\r\n};\r\n\r\n// Given a range of code points, add any case-folded code points in that range\r\n// to a set.\r\nregenerate.prototype.iuAddRange = function(min, max) {\r\n\tconst $this = this;\r\n\tdo {\r\n\t\tconst folded = caseFold(min);\r\n\t\tif (folded) {\r\n\t\t\t$this.add(folded);\r\n\t\t}\r\n\t} while (++min <= max);\r\n\treturn $this;\r\n};\r\n\r\nconst update = (item, pattern) => {\r\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\r\n\tswitch (tree.type) {\r\n\t\tcase 'characterClass':\r\n\t\tcase 'group':\r\n\t\tcase 'value':\r\n\t\t\t// No wrapping needed.\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// Wrap the pattern in a non-capturing group.\r\n\t\t\ttree = wrap(tree, pattern);\r\n\t}\r\n\tObject.assign(item, tree);\r\n};\r\n\r\nconst wrap = (tree, pattern) => {\r\n\t// Wrap the pattern in a non-capturing group.\r\n\treturn {\r\n\t\t'type': 'group',\r\n\t\t'behavior': 'ignore',\r\n\t\t'body': [tree],\r\n\t\t'raw': `(?:${ pattern })`\r\n\t};\r\n};\r\n\r\nconst caseFold = (codePoint) => {\r\n\treturn iuMappings.get(codePoint) || false;\r\n};\r\n\r\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\r\n\tconst set = regenerate();\r\n\tfor (const item of characterClassItem.body) {\r\n\t\tswitch (item.type) {\r\n\t\t\tcase 'value':\r\n\t\t\t\tset.add(item.codePoint);\r\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\r\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\r\n\t\t\t\t\tif (folded) {\r\n\t\t\t\t\t\tset.add(folded);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'characterClassRange':\r\n\t\t\t\tconst min = item.min.codePoint;\r\n\t\t\t\tconst max = item.max.codePoint;\r\n\t\t\t\tset.addRange(min, max);\r\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\r\n\t\t\t\t\tset.iuAddRange(min, max);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'characterClassEscape':\r\n\t\t\t\tset.add(getCharacterClassEscapeSet(\r\n\t\t\t\t\titem.value,\r\n\t\t\t\t\tconfig.unicode,\r\n\t\t\t\t\tconfig.ignoreCase\r\n\t\t\t\t));\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'unicodePropertyEscape':\r\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\r\n\t\t\t\tbreak;\r\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\r\n\t\t\t// reached. Code coverage tools should ignore it.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\r\n\t\t}\r\n\t}\r\n\tif (characterClassItem.negative) {\r\n\t\tupdate(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`)\r\n\t} else {\r\n\t\tupdate(characterClassItem, set.toString(regenerateOptions));\r\n\t}\r\n\treturn characterClassItem;\r\n};\r\n\r\nconst updateNamedReference = (item, index) => {\r\n\tdelete item.name;\r\n\titem.matchIndex = index;\r\n};\r\n\r\nconst assertNoUnmatchedReferences = (groups) => {\r\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\r\n\tif (unmatchedReferencesNames.length > 0) {\r\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\r\n\t}\r\n};\r\n\r\nconst processTerm = (item, regenerateOptions, groups) => {\r\n\tswitch (item.type) {\r\n\t\tcase 'dot':\r\n\t\t\tif (config.useDotAllFlag) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else if (config.unicode) {\r\n\t\t\t\tupdate(\r\n\t\t\t\t\titem,\r\n\t\t\t\t\tgetUnicodeDotSet(config.dotAll).toString(regenerateOptions)\r\n\t\t\t\t);\r\n\t\t\t} else if (config.dotAll) {\r\n\t\t\t\t// TODO: consider changing this at the regenerate level.\r\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'characterClass':\r\n\t\t\titem = processCharacterClass(item, regenerateOptions);\r\n\t\t\tbreak;\r\n\t\tcase 'unicodePropertyEscape':\r\n\t\t\tif (config.unicodePropertyEscape) {\r\n\t\t\t\tupdate(\r\n\t\t\t\t\titem,\r\n\t\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\r\n\t\t\t\t\t\t.toString(regenerateOptions)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'characterClassEscape':\r\n\t\t\tupdate(\r\n\t\t\t\titem,\r\n\t\t\t\tgetCharacterClassEscapeSet(\r\n\t\t\t\t\titem.value,\r\n\t\t\t\t\tconfig.unicode,\r\n\t\t\t\t\tconfig.ignoreCase\r\n\t\t\t\t).toString(regenerateOptions)\r\n\t\t\t);\r\n\t\t\tbreak;\r\n\t\tcase 'group':\r\n\t\t\tif (item.behavior == 'normal') {\r\n\t\t\t\tgroups.lastIndex++;\r\n\t\t\t}\r\n\t\t\tif (item.name && config.namedGroup) {\r\n\t\t\t\tconst name = item.name.value;\r\n\r\n\t\t\t\tif (groups.names[name]) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst index = groups.lastIndex;\r\n\t\t\t\tdelete item.name;\r\n\r\n\t\t\t\tgroups.names[name] = index;\r\n\t\t\t\tif (groups.onNamedGroup) {\r\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (groups.unmatchedReferences[name]) {\r\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\r\n\t\t\t\t\t\tupdateNamedReference(reference, index);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* falls through */\r\n\t\tcase 'alternative':\r\n\t\tcase 'disjunction':\r\n\t\tcase 'quantifier':\r\n\t\t\titem.body = item.body.map(term => {\r\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\r\n\t\t\t});\r\n\t\t\tbreak;\r\n\t\tcase 'value':\r\n\t\t\tconst codePoint = item.codePoint;\r\n\t\t\tconst set = regenerate(codePoint);\r\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\r\n\t\t\t\tconst folded = caseFold(codePoint);\r\n\t\t\t\tif (folded) {\r\n\t\t\t\t\tset.add(folded);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tupdate(item, set.toString(regenerateOptions));\r\n\t\t\tbreak;\r\n\t\tcase 'reference':\r\n\t\t\tif (item.name) {\r\n\t\t\t\tconst name = item.name.value;\r\n\t\t\t\tconst index = groups.names[name];\r\n\t\t\t\tif (index) {\r\n\t\t\t\t\tupdateNamedReference(item, index);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\r\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\r\n\t\t\t\t}\r\n\t\t\t\t// Keep track of references used before the corresponding group.\r\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'anchor':\r\n\t\tcase 'empty':\r\n\t\tcase 'group':\r\n\t\t\t// Nothing to do here.\r\n\t\t\tbreak;\r\n\t\t// The `default` clause is only here as a safeguard; it should never be\r\n\t\t// reached. Code coverage tools should ignore it.\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\r\n\t}\r\n\treturn item;\r\n};\r\n\r\nconst config = {\r\n\t'ignoreCase': false,\r\n\t'unicode': false,\r\n\t'dotAll': false,\r\n\t'useDotAllFlag': false,\r\n\t'useUnicodeFlag': false,\r\n\t'unicodePropertyEscape': false,\r\n\t'namedGroup': false\r\n};\r\nconst rewritePattern = (pattern, flags, options) => {\r\n\tconfig.unicode = flags && flags.includes('u');\r\n\tconst regjsparserFeatures = {\r\n\t\t'unicodePropertyEscape': config.unicode,\r\n\t\t'namedGroups': true,\r\n\t\t'lookbehind': options && options.lookbehind\r\n\t};\r\n\tconfig.ignoreCase = flags && flags.includes('i');\r\n\tconst supportDotAllFlag = options && options.dotAllFlag;\r\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\r\n\tconfig.namedGroup = options && options.namedGroup;\r\n\tconfig.useDotAllFlag = options && options.useDotAllFlag;\r\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\r\n\tconfig.unicodePropertyEscape = options && options.unicodePropertyEscape;\r\n\tif (supportDotAllFlag && config.useDotAllFlag) {\r\n\t\tthrow new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\r\n\t}\r\n\tconst regenerateOptions = {\r\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\r\n\t\t'bmpOnly': !config.unicode\r\n\t};\r\n\tconst groups = {\r\n\t\t'onNamedGroup': options && options.onNamedGroup,\r\n\t\t'lastIndex': 0,\r\n\t\t'names': Object.create(null), // { [name]: index }\r\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\r\n\t};\r\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\r\n\t// Note: `processTerm` mutates `tree` and `groups`.\r\n\tprocessTerm(tree, regenerateOptions, groups);\r\n\tassertNoUnmatchedReferences(groups);\r\n\treturn generate(tree);\r\n};\r\n\r\nmodule.exports = rewritePattern;\r\n"]},"metadata":{},"sourceType":"script"}